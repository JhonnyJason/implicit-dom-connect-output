// Generated by CoffeeScript 2.5.1
(function() {
  var BaseStateObject, ExactMatchStateObject, GeneralStateObject, SuperposedStateObject, addSelfSuperposingExactPattern, allStateObjects, considerPatternToStateFlow, considerPatterns, createMergedNextStates, currentBaseState, cursorPosition, enterBaseState, enterDefaultNextState, exactPatternToStateFlow, exactPatterns, fastsearchtreemodule, flowToNextState, ignorePatternToStateFlow, ignorePatterns, initialNextStates, initialState, input, log, mergeNextStates, mergeState, nextStates, olog, options, ostr, prepareStateFlowTree, print, printAllStateObjects, printNextLevel, printStateFlowTree, printThisLevelOnly, setExactMatchingState, setIgnoreState, setInitialState, setTokenMatchingState, stateFlowTree, superposedCount, terminateScan, terminateTokenMatchingState, tokenPatternToStateFlow, tokenPatterns, tokenStart, tokenTerminationStates, unpreparedStateObjects;

  fastsearchtreemodule = {
    name: "fastsearchtreemodule"
  };

  //###########################################################
  //region printLogFunctions
  log = function(arg) {
    if (allModules.debugmodule.modulesToDebug["fastsearchtreemodule"] != null) {
      console.log("[fastsearchtreemodule]: " + arg);
    }
  };

  ostr = function(obj) {
    return JSON.stringify(obj, null, 4);
  };

  olog = function(obj) {
    return log("\n" + ostr(obj));
  };

  print = function(arg) {
    return console.log(arg);
  };

  //endregion

  //###########################################################
  //region internalProperties
  options = {};

  initialState = null;

  stateFlowTree = {};

  initialNextStates = {};

  allStateObjects = [];

  unpreparedStateObjects = [];

  superposedCount = 0;

  //###########################################################
  //region globalState
  input = "";

  cursorPosition = 0;

  nextStates = null;

  enterDefaultNextState = null;

  currentBaseState = null;

  //endregion

  //###########################################################
  considerPatterns = [];

  ignorePatterns = [];

  exactPatterns = [];

  tokenPatterns = [];

  //###########################################################
  tokenTerminationStates = {};

  tokenStart = 0;

  //endregion

  //###########################################################
  fastsearchtreemodule.initialize = function() {
    log("fastsearchtreemodule.initialize");
    initialState = new BaseStateObject("initialState");
    setInitialState();
  };

  //###########################################################
  //region classes
  GeneralStateObject = class GeneralStateObject {
    constructor() {
      this.name = "unnamed GeneralStateObject";
      this.resultFunction = null;
      this.nextStates = null;
      this.followUpStates = {};
      this.printed = false;
      this.prepared = false;
      unpreparedStateObjects.push(this);
      allStateObjects.push(this);
      return;
    }

    print(prefix, symbol) {
      var r;
      r = "noResultFunction";
      if (this.resultFunction) {
        r = "hasResultFunction";
      }
      print("[" + prefix + symbol + "] -> " + this.type + "(" + r + ")");
    }

    prepare() {
      if (this.prepared) {
        return;
      }
      this.nextStates = this.followUpStates;
      this.prepared = true;
    }

    addFollowUpState(symbol, stateObject) {
      mergeState(this.followUpStates, symbol, stateObject);
    }

    superpose(stateObject) {
      var result;
      if (Object.is(stateObject, this)) {
        print(" - warning! we tried to superpose the stateObject on itself");
        return this;
      }
      print("superposing onto " + this.name + " <- " + stateObject.name);
      result = new SuperposedStateObject();
      result = result.superpose(this);
      result = result.superpose(stateObject);
      return result;
    }

    enterState() {
      nextStates = this.nextStates;
      if (this.resultFunction) {
        this.resultFunction();
      }
    }

  };

  SuperposedStateObject = class SuperposedStateObject extends GeneralStateObject {
    constructor() {
      super();
      superposedCount++;
      this.name = "superposed " + superposedCount + " ";
      this.type = "SuperposedStateObject";
      this.superposedStateObjects = [];
      this.assignedResultFunctions = [];
      print("constructed " + this.name);
      return;
    }

    resultFunction() {
      var j, k, len, len1, ref, ref1, resultFunction, stateObject;
      ref = this.superposedStateObjects;
      for (j = 0, len = ref.length; j < len; j++) {
        stateObject = ref[j];
        if (stateObject.resultFunction) {
          stateObject.resultFunction();
        }
      }
      ref1 = this.assignedResultFunctions;
      for (k = 0, len1 = ref1.length; k < len1; k++) {
        resultFunction = ref1[k];
        resultFunction();
      }
    }

    print(prefix, symbol) {
      var j, k, len, len1, r, ref, ref1, ref2, ref3, results, s, stateObject, states;
      s = 0;
      r = this.assignedResultFunctions.length;
      ref = this.superposedStateObjects;
      for (j = 0, len = ref.length; j < len; j++) {
        stateObject = ref[j];
        s++;
        if (stateObject.resultFunction) {
          r++;
        }
      }
      states = " " + s + " states ";
      results = " " + r + " resultFunctions ";
      print("[" + prefix + symbol + "] -> " + this.name + "(" + states + " | " + results + ")");
      ref1 = this.superposedStateObjects;
      for (k = 0, len1 = ref1.length; k < len1; k++) {
        stateObject = ref1[k];
        stateObject.print("subState", "");
      }
      if (this.followUpStates) {
        print("followUpStates:");
        ref2 = this.followUpStates;
        for (symbol in ref2) {
          stateObject = ref2[symbol];
          print("  " + symbol + " -> " + stateObject.name);
        }
      }
      if (this.nextStates) {
        print("nextStates:");
        ref3 = this.nextStates;
        for (symbol in ref3) {
          stateObject = ref3[symbol];
          print("  " + symbol + " -> " + stateObject.name);
        }
      }
      print("");
    }

    prepare() {
      var j, len, ref, stateObject;
      print("... preparing " + this.name + " isPrepared:" + this.prepared);
      if (this.prepared) {
        return;
      }
      this.followUpStates = {};
      ref = this.superposedStateObjects;
      for (j = 0, len = ref.length; j < len; j++) {
        stateObject = ref[j];
        stateObject.prepare();
        this.followUpStates = createMergedNextStates(this.followUpStates, stateObject.nextStates);
      }
      this.nextStates = this.followUpStates;
      this.prepared = true;
      print("... prepared " + this.name);
      this.print("-", "");
    }

    superpose(stateObject) {
      if (Object.is(stateObject, this)) {
        print(" - warning! we tried to superpose the stateObject on itself");
        return this;
      }
      print("superposing onto " + this.name + " <- " + stateObject.name);
      if (!this.superposedStateObjects.includes(stateObject)) {
        this.superposedStateObjects.push(stateObject);
      }
      // result = new SuperposedStateObject()
      // result = result.superpose(this)
      // result = result.superpose(stateObject)

      // if stateObject.type == "SuperposedStateObject"
      //     for subStateObject in stateObject.superposedStateObjects
      //         if !@superposedStateObjects.includes(subStateObject)
      //             @superposedStateObjects.push(subStateObject)        
      // else if !@superposedStateObjects.includes(stateObject)
      //     @superposedStateObjects.push(stateObject)
      return this;
    }

  };

  // assignResultFunction: (resultFunction) ->
  //     @assignedResultFunctions.push(resultFunction)
  //     return

    //region oldCode
  // getFollowUpStateObject: (symbol) ->
  //     log "!! trying to get FollowUpObject pf SuperposedStateObject..."
  //     stateObject = @followUpStates[symbol]
  //     if !stateObject
  //         stateObject = new ExactMatchStateObject()
  //         @followUpStates[symbol] = stateObject
  //     return stateObject    

    // reflectOtherState: (stateObject) ->
  //     if Object.is(stateObject, this)
  //         log "!!! - we tried to reflect the state of the Superpositioned StateObject in itself!!"
  //         return
  //     return if @superposedStateObjects.includes(stateObject)
  //     if stateObject.type == "SuperposedStateObject"
  //         for subStateObject in stateObject.superposedStateObjects
  //             @superposedStateObjects.push(subStateObject)
  //         return        
  //     @superposedStateObjects.push(stateObject)
  //     return
  //endregion
  BaseStateObject = class BaseStateObject extends GeneralStateObject {
    constructor(name) {
      super();
      this.name = name;
      this.type = "BaseStateObject";
      print("constructed " + this.name);
      return;
    }

    print(prefix, symbol) {
      var f, nextStateObject, p, ref, ref1, stateObject;
      f = Object.keys(this.followUpStates);
      p = "unprepared";
      if (this.prepared) {
        p = "is prepared";
      }
      print("[" + prefix + symbol + "] -> " + this.name + " [" + f + "]");
      print("[" + prefix + symbol + "] " + p);
      if (this.followUpStates) {
        print("followUpStates:");
        ref = this.followUpStates;
        for (symbol in ref) {
          stateObject = ref[symbol];
          print("  " + symbol + " -> " + stateObject.name);
        }
      }
      if (this.prepared) {
        ref1 = this.nextStates;
        for (symbol in ref1) {
          nextStateObject = ref1[symbol];
          print("[" + prefix + symbol + "] next -> " + nextStateObject.name);
        }
      }
      print("");
    }

    // prepare: ->
    //     print "... preparing "+@name+" isPrepared:"+@prepared
    //     if @prepared then return
    //     @nextStates = @followUpStates
    //     @prepared = true
    //     print "... prepared "+@name
    //     @print("-", "")
    //     return
    enterState() {
      nextStates = this.nextStates;
      currentBaseState = this;
    }

  };

  ExactMatchStateObject = class ExactMatchStateObject extends GeneralStateObject {
    constructor(pattern1, index1) {
      super();
      this.pattern = pattern1;
      this.index = index1;
      this.type = "ExactMatchStateObject";
      this.name = "exactMatch " + this.pattern + "[" + this.index + "]";
      print("constructed " + this.name);
      return;
    }

    print(prefix, symbol) {
      var f, nextStateObject, p, r, ref, ref1, stateObject;
      r = "noResultFunction";
      if (this.resultFunction) {
        r = "hasResultFunction";
      }
      f = Object.keys(this.followUpStates);
      p = "unprepared";
      if (this.prepared) {
        p = "is prepared";
      }
      print("[" + prefix + symbol + "] -> " + this.name + " (" + r + ") [" + f + "]");
      print("[" + prefix + symbol + "] " + p);
      if (this.followUpStates) {
        print("followUpStates:");
        ref = this.followUpStates;
        for (symbol in ref) {
          stateObject = ref[symbol];
          print("  " + symbol + " -> " + stateObject.name);
        }
      }
      if (this.prepared) {
        ref1 = this.nextStates;
        for (symbol in ref1) {
          nextStateObject = ref1[symbol];
          print("[" + prefix + symbol + "] next -> " + nextStateObject.name);
        }
      }
      print("");
    }

    // prepare: ->
    //     print "... preparing "+@name+" isPrepared:"+@prepared
    //     if @prepared then return
    //     @nextStates = @followUpStates
    //     @prepared = true
    //     print "... prepared "+@name
    //     @print("-", "")
    //     return
    superpose(stateObject) {
      var result;
      if (Object.is(stateObject, this)) {
        print(" - warning! we tried to superpose the stateObject on itself");
        return this;
      }
      print("superposing onto " + this.name + " <- " + stateObject.name);
      result = new SuperposedStateObject();
      result = result.superpose(this);
      result = result.superpose(stateObject);
      return result;
    }

    assignResultFunction(resultFunction) {
      this.resultFunction = resultFunction;
    }

  };

  //region oldCode
  // getFollowUpStateObject: (symbol) ->
  //     stateObject = @followUpStates[symbol]
  //     if !stateObject
  //         stateObject = new ExactMatchStateObject()
  //         @followUpStates[symbol] = stateObject
  //     return stateObject    
  //endregion

  //endregion

  //###########################################################
  //region internalFunctions
  printAllStateObjects = function() {
    var j, len, stateObject;
    print("=> print allStateObjects");
    for (j = 0, len = allStateObjects.length; j < len; j++) {
      stateObject = allStateObjects[j];
      stateObject.print("", "-");
    }
    print("");
  };

  printStateFlowTree = function() {
    var initialSymbols, j, k, len, len1, stateObject, symbol;
    print("=> print the stateFlowTree");
    for (j = 0, len = allStateObjects.length; j < len; j++) {
      stateObject = allStateObjects[j];
      stateObject.printed = false;
    }
    initialSymbols = Object.keys(initialState.nextStates);
    print("> printing initialNextStates for " + initialSymbols);
    for (k = 0, len1 = initialSymbols.length; k < len1; k++) {
      symbol = initialSymbols[k];
      stateObject = initialState.nextStates[symbol];
      if (stateObject.printed) {
        continue;
      }
      stateObject.print("", symbol);
      stateObject.printed = true;
      printNextLevel(symbol, stateObject);
    }
    print("");
  };

  printNextLevel = function(prefix, stateObject) {
    var j, len, nextLevelSymbols, nextStateObject, symbol;
    print("> printing nextStates");
    if (!stateObject.nextStates) {
      print("there where no nextStates to print!");
      return;
    }
    nextLevelSymbols = Object.keys(stateObject.nextStates);
    print("[" + prefix + "] -> nextLevelSymbols: " + nextLevelSymbols);
    for (j = 0, len = nextLevelSymbols.length; j < len; j++) {
      symbol = nextLevelSymbols[j];
      nextStateObject = stateObject.nextStates[symbol];
      if (nextStateObject.printed) {
        print("> " + nextStateObject.name + " was marked as printed...");
        continue;
      }
      nextStateObject.print(prefix, symbol);
      nextStateObject.printed = true;
      printNextLevel(prefix + symbol, nextStateObject);
    }
  };

  printThisLevelOnly = function(prefix, level) {
    var j, len, nextLevelSymbols, nextStateObject, symbol;
    nextLevelSymbols = Object.keys(level);
    for (j = 0, len = nextLevelSymbols.length; j < len; j++) {
      symbol = nextLevelSymbols[j];
      nextStateObject = level[symbol];
      nextStateObject.print(prefix, symbol);
    }
  };

  //###########################################################
  prepareStateFlowTree = function() {
    var j, len, stateObject;
    print("=> prepare the stateFlowTree");
    for (j = 0, len = allStateObjects.length; j < len; j++) {
      stateObject = allStateObjects[j];
      stateObject.prepared = false;
      if (!unpreparedStateObjects.includes(stateObject)) {
        unpreparedStateObjects.push(stateObject);
      }
    }
    while (unpreparedStateObjects.length) {
      stateObject = unpreparedStateObjects.pop();
      stateObject.prepare();
    }
    print("");
  };

  //###########################################################
  createMergedNextStates = function(states1, states2) {
    var resultingStates;
    log("createMergedNextStates");
    resultingStates = {};
    mergeNextStates(resultingStates, states1);
    mergeNextStates(resultingStates, states2);
    return resultingStates;
  };

  // for symbol,stateObject of states2
  //     if resultingStates[symbol] and !Object.is(stateObject, resultingStates[symbol])
  //         if stateObject.type == "SuperposedStateObject"
  //             stateObject.reflectOtherState(resultingStates[symbol])
  //             resultingStates[symbol] = stateObject
  //         else if resultingStates[symbol].type == "SuperposedStateObject"
  //             resultingStates[symbol].reflectOtherState(stateObject)
  //         else
  //             superposition = new SuperposedStateObject()
  //             superposition.reflectOtherState(resultingStates[symbol])
  //             superposition.reflectOtherState(stateObject)
  //             resultingStates[symbol] = superposition
  //     else resultingStates[symbol] = stateObject
  mergeState = function(states, symbol, stateObject) {
    log("mergeState");
    if (states[symbol]) {
      states[symbol] = states[symbol].superpose(stateObject);
    } else {
      states[symbol] = stateObject;
    }
  };

  mergeNextStates = function(states1, states2) {
    var stateObject, symbol;
    log("mergeNextStates");
    for (symbol in states2) {
      stateObject = states2[symbol];
      mergeState(states1, symbol, stateObject);
    }
  };

  //###########################################################
  //region stateFlowFunctions
  setInitialState = function() {
    log("setInitialState");
    initialState.enterState();
    enterDefaultNextState = enterBaseState;
  };

  flowToNextState = function(symbol) {
    if (nextStates[symbol]) {
      nextStates[symbol].enterState();
    } else {
      enterDefaultNextState();
    }
  };

  enterBaseState = function() {
    log("enterBaseState");
    currentBaseState.enterState();
  };

  //###########################################################
  terminateScan = function() {};

  //region oldCode

  //# TODO implement
  setIgnoreState = function(escapeKey) {
    log("setIgnoreState");
    nextStates = {};
    nextStates[escapeKey] = setInitialState;
    enterDefaultNextState = function() {};
  };

  terminateTokenMatchingState = function() {
    var char, j, len, pattern, result;
    log("terminateTokenMatchingState");
    char = input[cursorPosition];
    log("cursorPosition: " + cursorPosition);
    log("char: " + char);
    result = input.substring(tokenStart, cursorPosition);
    log("result: " + result);
    for (j = 0, len = tokenPatterns.length; j < len; j++) {
      pattern = tokenPatterns[j];
      if (pattern.terminationPattern[0] === char) {
        if (pattern.resultFunction) {
          pattern.resultFunction(result, input, cursorPosition);
        }
      }
    }
    nextStates = {};
    enterDefaultNextState = function() {};
  };

  setTokenMatchingState = function() {
    var startKey;
    log("setTokenMatchingState");
    tokenStart = cursorPosition;
    startKey = input[cursorPosition];
    nextStates = tokenTerminationStates[startKey];
    enterDefaultNextState = function() {};
  };

  setExactMatchingState = function(exactPattern, index) {
    var nextIndex, nextKey;
    log("setExactMatchingState");
    // log "index: " + index
    // olog exactPattern
    // olog nextStates
    if (exactPattern.pattern.length === index && exactPattern.resultFunction) {
      exactPattern.resultFunction(exactPattern.pattern, input, cursorPosition);
      nextStates = {};
      enterDefaultNextState = function() {};
      return;
    }
    nextKey = exactPattern.pattern[index];
    nextIndex = index + 1;
    nextStates = {};
    nextStates[nextKey] = function() {
      return setExactMatchingState(exactPattern, nextIndex);
    };
    enterDefaultNextState = setInitialState;
  };

  //endregion
  //endregion

  //###########################################################
  //region patterrnsToStateFlow
  // log "nextKey: " + nextKey
  // log "nextStates Keys: " + Object.keys(nextStates)
  // log "initialState Keys: " + Object.keys(initialNextStates)
  addSelfSuperposingExactPattern = function(pattern, resultFunction) {
    var i, j, k, l, len, len1, len2, state, stateSequence, superposedSequence, symbol;
    log("addSelfSuperposingExactPattern");
    //region exactPathToExecution
    stateSequence = [];
    for (i = j = 0, len = pattern.length; j < len; i = ++j) {
      symbol = pattern[i];
      state = new ExactMatchStateObject(pattern, i);
      // if i > 0 then stateSequence[i-1].addFollowUpState(symbol, state)
      stateSequence.push(state);
    }
    stateSequence[stateSequence.length - 1].assignResultFunction(resultFunction);
    //endregion

    //region superposeWithInitialState
    superposedSequence = [];
    for (i = k = 0, len1 = stateSequence.length; k < len1; i = ++k) {
      state = stateSequence[i];
      superposedSequence.push(state.superpose(initialState));
    }

    //connect everything with the superposed states
    for (i = l = 0, len2 = pattern.length; l < len2; i = ++l) {
      symbol = pattern[i];
      if (i > 0) {
        stateSequence[i - 1].addFollowUpState(symbol, superposedSequence[i]);
      }
    }
    initialState.addFollowUpState(pattern[0], superposedSequence[0]);
    //endregion
    print("");
    printAllStateObjects();
    prepareStateFlowTree();
    printStateFlowTree();
  };

  exactPatternToStateFlow = function(exactPattern) {
    var executableResultFunction, pattern, resultFunction;
    log("exactPatternToStateFlow");
    pattern = exactPattern.pattern;
    resultFunction = exactPattern.resultFunction;
    executableResultFunction = function() {
      return resultFunction("", input, cursorPosition);
    };
    addSelfSuperposingExactPattern(pattern, executableResultFunction);
  };

  // startSymbol = pattern[0]

  // startState = new ExactMatchStateObject(pattern, 0)
  // initialState.addFollowUpState(startSymbol, startState)

  // stateObject = startState
  // index = 1
  // while index < pattern.length
  //     latestStateObject = stateObject
  //     symbol = pattern[index]
  //     stateObject = new ExactMatchStateObject(pattern, index)
  //     latestStateObject.addFollowUpState(symbol, stateObject)        
  //     ++index

  // stateObject.assignResultFunction(executableResultFunction)

  // print ""
  // printAllStateObjects()
  // prepareStateFlowTree()
  // printStateFlowTree()
  // return

  //region oldCode
  tokenPatternToStateFlow = function(ambiguousPattern) {
    throw "tokenPatternToStateFlow - not implemented yet";
  };

  //#TODO implement
  // key = ambiguousPattern.startPattern[0]
  // if !initialNextStates[key]
  //     initialNextStates[key] = setTokenMatchingState
  //     tokenTerminationStates[key] = {}
  // terminationKey = ambiguousPattern.terminationPattern[0]
  // tokenTerminationStates[key][terminationKey] = terminateTokenMatchingState
  ignorePatternToStateFlow = function(ignorePattern) {
    throw "ignorePatternToStateFlow - not implemented yet";
  };

  //#TODO implement
  // key = ignorePattern.startPattern[0]
  // escapeKey = ignorePattern.terminationPattern[0]
  // nextStateFunction = -> setIgnoreState(escapeKey)
  // initialNextStates[key] = nextStateFunction
  considerPatternToStateFlow = function(considerPattern) {
    throw "considerPatternToStateFlow - not implemented yet";
  };

  //endregion
  //endregion

  //endregion

  //###########################################################
  //region exposedFunctions
  //#TODO implement
  fastsearchtreemodule.scan = function(newInput) {
    var index, j, len, symbol;
    log("fastsearchtreemodule.scan");
    setInitialState();
    input = newInput;
    for (index = j = 0, len = input.length; j < len; index = ++j) {
      symbol = input[index];
      cursorPosition = index;
      flowToNextState(symbol);
    }
    terminateScan();
  };

  fastsearchtreemodule.reset = function(newOptions) {
    log("fastsearchtreemodule.reset");
    options = newOptions;
    cursorPosition = 0;
    input = "";
    initialState = null;
    nextStates = null;
    currentBaseState = null;
    enterDefaultNextState = null;
    allStateObjects = [];
    superposedCount = 0;
    unpreparedStateObjects = [];
    //region unused variables    
    tokenTerminationStates = {};
    tokenStart = 0;
    exactPatterns = [];
    tokenPatterns = [];
    ignorePatterns = [];
    //endregion
    initialState = new BaseStateObject("initialState");
    setInitialState();
  };

  //###########################################################
  //region addingPatterns
  fastsearchtreemodule.addExactMatchPattern = function(pattern, resultFunction) {
    var exactPattern;
    log("fastsearchtreemodule.addExactMatchPattern");
    exactPattern = {
      pattern: pattern,
      resultFunction: resultFunction
    };
    exactPatternToStateFlow(exactPattern);
  };

  //region unimplementedCode
  fastsearchtreemodule.addTokenMatchPattern = function(startPattern, terminationPattern, resultFunction) {
    var tokenPattern;
    log("fastsearchtreemodule.addTokenMatchPattern");
    tokenPattern = {
      startPattern: startPattern,
      terminationPattern: terminationPattern,
      resultFunction: resultFunction
    };
    tokenPatterns.push(ambiguousPattern);
  };

  //TODO add that one pattern to the stateFlowTree
  fastsearchtreemodule.addIgnoreSequence = function(startPattern, terminationPattern) {
    var ignorePattern;
    log("fastsearchtreemodule.addIgnoreSequence");
    ignorePattern = {
      startPattern: startPattern,
      terminationPattern: terminationPattern
    };
    ignorePatterns.push(ignorePattern);
  };

  //TODO add that one pattern to the stateFlowTree
  fastsearchtreemodule.addConsiderSequence = function(startPattern, terminationPattern) {
    var considerPattern;
    log("fastsearchtreemodule.addConsiderSequence");
    considerPattern = {
      startPattern: startPattern,
      terminationPattern: terminationPattern
    };
    considerPatterns.push(ignorePattern);
  };

  //endregion

  //endregion

  //endregion
  //#TODO add that one pattern to the stateFlowTree
  module.exports = fastsearchtreemodule;

}).call(this);
