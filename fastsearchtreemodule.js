// Generated by CoffeeScript 2.5.1
(function() {
  var ambiguousPatternToStateFlow, ambiguousPatterns, ambiguousStart, ambiguousTerminationStates, breakState, checkNextState, cursorPosition, fastsearchtreemodule, flushPatternsToStateFlow, ignorePatternToStateFlow, ignorePatterns, initialNextStates, input, log, nextStates, olog, ostr, print, setAmbiguousMatchingState, setIgnoreState, setInitialState, setUnambiguousMatchingState, terminateAmbiguousState, unambiguousPatternToStateFlow, unambiguousPatterns;

  fastsearchtreemodule = {
    name: "fastsearchtreemodule"
  };

  //###########################################################
  //region printLogFunctions
  log = function(arg) {
    if (allModules.debugmodule.modulesToDebug["fastsearchtreemodule"] != null) {
      console.log("[fastsearchtreemodule]: " + arg);
    }
  };

  ostr = function(obj) {
    return JSON.stringify(obj, null, 4);
  };

  olog = function(obj) {
    return log("\n" + ostr(obj));
  };

  print = function(arg) {
    return console.log(arg);
  };

  //endregion

  //###########################################################
  //region internalProperties
  initialNextStates = {};

  //###########################################################
  unambiguousPatterns = [];

  ambiguousPatterns = [];

  ignorePatterns = [];

  //###########################################################
  nextStates = null;

  cursorPosition = 0;

  input = "";

  breakState = null;

  //###########################################################
  ambiguousTerminationStates = {};

  ambiguousStart = 0;

  //endregion

  //###########################################################
  fastsearchtreemodule.initialize = function() {
    log("fastsearchtreemodule.initialize");
    setInitialState();
  };

  //###########################################################
  //region internalFunctions
  checkNextState = function(char) {
    if (nextStates[char]) {
      nextStates[char]();
    } else {
      breakState();
    }
  };

  //###########################################################
  //region stateFunctions
  setInitialState = function() {
    log("setInitialState");
    nextStates = initialNextStates;
    breakState = function() {};
  };

  setIgnoreState = function(escapeKey) {
    log("setIgnoreState");
    nextStates = {};
    nextStates[escapeKey] = setInitialState;
    breakState = function() {};
  };

  terminateAmbiguousState = function() {
    var char, i, len, pattern, result;
    log("terminateAmbiguousState");
    char = input[cursorPosition];
    log("cursorPosition: " + cursorPosition);
    log("char: " + char);
    result = input.substring(ambiguousStart, cursorPosition);
    log("result: " + result);
    for (i = 0, len = ambiguousPatterns.length; i < len; i++) {
      pattern = ambiguousPatterns[i];
      if (pattern.terminationPattern[0] === char) {
        if (pattern.resultFunction) {
          pattern.resultFunction(result, input, cursorPosition);
        }
      }
    }
    nextStates = {};
    breakState = function() {};
  };

  setAmbiguousMatchingState = function() {
    var startKey;
    log("setAmbiguousMatchingState");
    ambiguousStart = cursorPosition;
    startKey = input[cursorPosition];
    nextStates = ambiguousTerminationStates[startKey];
    breakState = function() {};
  };

  setUnambiguousMatchingState = function(unambiguousPattern, index) {
    var nextIndex, nextKey;
    log("setUnambiguousMatchingState");
    // log "index: " + index
    // olog unambiguousPattern
    // olog nextStates
    if (unambiguousPattern.pattern.length === index && unambiguousPattern.resultFunction) {
      unambiguousPattern.resultFunction(unambiguousPattern.pattern, input, cursorPosition);
      nextStates = {};
      breakState = function() {};
      return;
    }
    nextKey = unambiguousPattern.pattern[index];
    nextIndex = index + 1;
    nextStates = {};
    nextStates[nextKey] = function() {
      return setUnambiguousMatchingState(unambiguousPattern, nextIndex);
    };
    breakState = setInitialState;
  };

  //endregion

  //###########################################################
  //region patterrnsToStateFlow
  // log "nextKey: " + nextKey
  // log "nextStates Keys: " + Object.keys(nextStates)
  // log "initialState Keys: " + Object.keys(initialNextStates)
  flushPatternsToStateFlow = function() {
    log("flushPatternsToStateFlow");
    ignorePatterns.forEach(ignorePatternToStateFlow);
    unambiguousPatterns.forEach(unambiguousPatternToStateFlow);
    ambiguousPatterns.forEach(ambiguousPatternToStateFlow);
  };

  //###########################################################
  ignorePatternToStateFlow = function(ignorePattern) {
    var escapeKey, key, nextStateFunction;
    key = ignorePattern.startPattern[0];
    escapeKey = ignorePattern.terminationPattern[0];
    nextStateFunction = function() {
      return setIgnoreState(escapeKey);
    };
    initialNextStates[key] = nextStateFunction;
  };

  unambiguousPatternToStateFlow = function(unambiguousPattern) {
    var key, nextStateFunction;
    key = unambiguousPattern.pattern[0];
    nextStateFunction = function() {
      return setUnambiguousMatchingState(unambiguousPattern, 1);
    };
    initialNextStates[key] = nextStateFunction;
  };

  ambiguousPatternToStateFlow = function(ambiguousPattern) {
    var key, terminationKey;
    key = ambiguousPattern.startPattern[0];
    if (!initialNextStates[key]) {
      initialNextStates[key] = setAmbiguousMatchingState;
      ambiguousTerminationStates[key] = {};
    }
    terminationKey = ambiguousPattern.terminationPattern[0];
    ambiguousTerminationStates[key][terminationKey] = terminateAmbiguousState;
  };

  //endregion

  //endregion

  //###########################################################
  //region exposedFunctions
  fastsearchtreemodule.scan = function(newInput) {
    var char, i, index, len;
    log("fastsearchtreemodule.scan");
    setInitialState();
    input = newInput;
    for (index = i = 0, len = input.length; i < len; index = ++i) {
      char = input[index];
      cursorPosition = index;
      checkNextState(char);
    }
  };

  fastsearchtreemodule.reset = function() {
    log("fastsearchtreemodule.reset");
    initialNextStates = {};
    cursorPosition = 0;
    input = "";
    ambiguousTerminationStates = {};
    ambiguousStart = 0;
    unambiguousPatterns = [];
    ambiguousPatterns = [];
    ignorePatterns = [];
    setInitialState();
  };

  //###########################################################
  //region addingPatterns
  fastsearchtreemodule.addUnambiguousFindPattern = function(pattern, resultFunction) {
    var unambiguousPattern;
    log("fastsearchtreemodule.addUnambigousFindPattern");
    unambiguousPattern = {
      pattern: pattern,
      resultFunction: resultFunction
    };
    unambiguousPatterns.push(unambiguousPattern);
    flushPatternsToStateFlow();
  };

  fastsearchtreemodule.addAmbiguousFindPattern = function(startPattern, terminationPattern, resultFunction) {
    var ambiguousPattern;
    log("fastsearchtreemodule.addAmbiguousFindPattern");
    ambiguousPattern = {
      startPattern: startPattern,
      terminationPattern: terminationPattern,
      resultFunction: resultFunction
    };
    ambiguousPatterns.push(ambiguousPattern);
    flushPatternsToStateFlow();
  };

  fastsearchtreemodule.addIgnoreSequence = function(startPattern, terminationPattern) {
    var ignorePattern;
    log("fastsearchtreemodule.addIgnoreSequence");
    ignorePattern = {
      startPattern: startPattern,
      terminationPattern: terminationPattern
    };
    ignorePatterns.push(ignorePattern);
    flushPatternsToStateFlow();
  };

  //endregion

  //endregion
  module.exports = fastsearchtreemodule;

}).call(this);
